//Path panel item creates new canvas in a DOM element of choice and all attached items are drawn on this canvas.
function PathPanelItem(elem,w,h) {
    this.domele = elem;
    this.canvasSettings = {container: elem, width: w, height: h};
    this.canvas = new Kinetic.Stage(this.canvasSettings);
}

//This class keeps track of all VHI (virtual helix item) and maintains an uniform standard for VHIs.
function VirtualHelixSet(panel,gridMode,sqlen,sx,sy) {
    this.pathpanel = panel;
    //copying input params so attached items can use them
    this.canvas = panel.canvas;
    this.mode = gridMode;
    this.sqLength = sqlen;
    this.startX = sx;
    this.startY = sy;
    //items that latch on to the set: an array of VirtualHelixItem and PathSlidebarItem
    this.vhiArray = new Array();
    this.slidebar; //initialize only when vhiArray is not empty
    //grid and divider
    this.grLength = new Number;
    this.divLength = new Number;
    if(this.mode === "honeycomb") {
	this.grLength = 42;
	this.divLength = 7;
    }
    else if(this.mode === "square") {
	this.grLength = 64;
	this.divLength = 8;
    }
    else { //You better check for typos!
	alert("Grid type does not exist, script aborted");
	throw "stop execution";
    }
}
//resizes panel such that everything just fits in; this function shouldn't really be in this class but w/e...
VirtualHelixSet.prototype.resize = function() {
    this.canvas.setSize(2*this.startX+this.sqLength*this.grLength+2*Math.floor(this.grLength/this.divLength),2*this.startY+4*this.vhiArray.length*this.sqLength);
};
//add & remove VHI to vhiArray, as well as slidebar update
VirtualHelixSet.prototype.addVHI = function() {
    this.vhiArray.push(new VirtualHelixItem(this));
    if(this.vhiArray.length === 1) {
	this.slidebar = new PathSlidebarItem(this);
    }
    this.slidebar.update();
    this.resize();
};
VirtualHelixSet.prototype.removeVHI = function() {
    this.vhiArray[this.vhiArray.length-1].layer.remove();
    this.vhiArray.pop();
    if(this.vhiArray.length != 0) {
	this.slidebar.update();
    }
    else {
	this.slidebar.layer.remove();
	this.slidebar = undefined;
    }
    this.resize();
};
//updates existing VHIs to correct length and changes grLength for future VHIs
VirtualHelixSet.prototype.updateLen = function(nl) {
    if(nl === null) {return;}
    var newLen = parseInt(nl,10); //nl (used to be newLen) and this.grLength was interpreted as strings, causing errors
    for(var k=0; k<this.vhiArray.length; k++) {
	var vhi = this.vhiArray[k];
	//adding bases
	if(newLen >= this.grLength) {
	    for(var i=parseInt(this.grLength,10); i<parseInt(newLen,10); i++) {
		for(var j=0; j<2; j++) {
		    var rect = new Kinetic.Rect({
			    x: vhi.startX+i*vhi.sqLength+2*Math.floor(i/this.divLength),
			    y: vhi.startY+j*vhi.sqLength,
			    width: vhi.sqLength,
			    height: vhi.sqLength,
			    fill: "#FFFFFF",
			    stroke: "#DDDDDD",
			    strokeWidth: 2
			});
		    vhi.baseArray[j][i] = rect;
		    vhi.layer.add(rect);
		}
	    }
	}
	else {
	    for(var i=parseInt(newLen,10); i<parseInt(this.grLength,10); i++) {
		for(var j=0; j<2; j++) {
		    vhi.baseArray[j][i].remove();
		    vhi.baseArray[j][i] = undefined;
		}
	    }
	}
	vhi.layer.draw();
    }
    //if removing bases, move the slidebar to visible area
    if(newLen < this.grLength && newLen-1 < this.slidebar.getCounter()) {
	this.slidebar.setCounter(newLen-1);
	this.slidebar.group.setX(this.slidebar.getCounter()*this.sqLength+2*Math.floor(this.slidebar.getCounter()/this.divLength));
	this.slidebar.counterText.setText(this.slidebar.getCounter());
	this.slidebar.layer.draw();
    }
    this.grLength = newLen;
    this.resize();
};

//VHI is the collection of bases as well as the corresponding HelixCounterItem
function VirtualHelixItem(vhiSet) {
    this.helixset = vhiSet;
    //taking params from VirtualHelixSet
    this.num = vhiSet.vhiArray.length;
    this.sqLength = vhiSet.sqLength;
    this.startX = vhiSet.startX;
    this.startY = vhiSet.startY + 4*this.num*this.sqLength;
    this.canvas = vhiSet.canvas;
    this.layer = new Kinetic.Layer();
    this.counter = new HelixCounterItem(this);
    //an 2D array that keeps track of bases; it's in (y,x) instead of the more popular form (x,y) because of eaiser base addition & removal
    this.baseArray = new Array();
    this.baseArray[0] = new Array();
    this.baseArray[1] = new Array();
    //array construction
    for(var i=0; i<vhiSet.grLength; i++) {
	for(var j=0; j<2; j++) {
	    var rect = new Kinetic.Rect({
		    x: this.startX+i*this.sqLength+2*Math.floor(i/vhiSet.divLength),
		    y: this.startY+j*this.sqLength,
		    width: this.sqLength,
		    height: this.sqLength,
		    fill: "#FFFFFF",
		    stroke: "#DDDDDD",
		    strokeWidth: 2
		});
	    this.baseArray[j][i] = rect;
	    this.layer.add(rect);
	}
    }
    //add layer to canvas
    this.canvas.add(this.layer);
};

//The name of this class is rather self-explanatory...
function HelixCounterItem(vhi) {
    var layer = vhi.layer;
    //circle
    var circle = new Kinetic.Circle({
	    radius: vhi.sqLength,
	    x: vhi.startX-3*vhi.sqLength,
	    y: vhi.startY+vhi.sqLength,
	    fill: "#FFE400",
	    stroke: "#808080",
	    strokeWidth: 2
        });
    layer.add(circle);
    circle.on("mouseenter", function() {circle.setStroke("#3333FF"); layer.draw();});
    circle.on("mouseleave", function() {circle.setStroke("#808080"); layer.draw();});
    //number in the middle of circle
    var helixNumText = new Kinetic.Text({
	    x: circle.getX(),
	    y: circle.getY()-circle.getRadius()/2,
	    text: vhi.num,
	    fontSize: vhi.sqLength,
	    fontFamily: "Calibri",
	    fill: "#000000",
	});
    helixNumText.setOffset({
	    x: helixNumText.getWidth()/2
	});
    layer.add(helixNumText);
    //bug fix: circle not highlighted when mouse is on text
    helixNumText.on("mouseenter", function() {circle.setStroke("#3333FF"); layer.draw();});
    helixNumText.on("mouseleave", function() {circle.setStroke("#808080"); layer.draw();});
}

//draggable slidebar on top of VHIs
function PathSlidebarItem(vhis) {
    this.counter = 0;
    this.vhiSet = vhis;
    this.layer = new Kinetic.Layer();
    this.top = this.vhiSet.vhiArray[0].startY-2*this.vhiSet.sqLength;
    this.bot = 0;
    this.rect = new Kinetic.Rect({
	    x: this.vhiSet.startX+this.getCounter()*this.vhiSet.sqLength,
	    y: this.top,
	    width: this.vhiSet.sqLength,
	    height: this.bot-this.top,
	    fill: "#FFAA80",
	    stroke: "#000000",
	    strokeWidth: 1,
	    opacity: 0.5
	});
    var rect = this.rect;
    this.counterText = new Kinetic.Text({
	    x: this.vhiSet.startX+(this.getCounter()+0.5)*this.vhiSet.sqLength,
	    y: this.top-18,
	    text: this.getCounter(),
	    fontSize: 16,
	    fontFamily: "Calibri",
	    fill: "#000000",
	});
    var counterText = this.counterText;
    counterText.setOffset({
	    x: counterText.getWidth()/2
	});
    this.group = new Kinetic.Group({
	    draggable: true,
	    dragBoundFunc: function(pos) {
		//changing text settings; these lines are here so it can be in sync with the bar
		//if you still don't understand, put the 2 lines after counter mechanism and drag your mouse near border
		counterText.setText(vhis.slidebar.getCounter());
		counterText.setOffset({x: counterText.getWidth()/2});
		//limit slidebar to be right on top of bases
		return {
		    x: vhis.slidebar.getCounter()*vhis.sqLength+2*Math.floor(vhis.slidebar.getCounter()/vhis.divLength), //more ugly code thanks for thicker divider
		    y: this.getAbsolutePosition().y
		}
	    }
	});
    this.group.add(this.rect);
    this.group.add(this.counterText);
    this.group.on("dragmove", function(pos) {
	    //actually, that wasn't too bad compared to this... welcome to the new counter calculation mecahnism
	    var blockLen = vhis.divLength*vhis.sqLength+2;

	    //Delete these 2 lines and uncomment the now commented 2 lines when integrating with cadnano3.html
	    var blockNum = Math.floor((pos.x+document.body.scrollLeft-vhis.startX-1)/blockLen);
	    var tempCounter = Math.floor((pos.x+document.body.scrollLeft-(blockNum*blockLen+vhis.startX+1))/vhis.sqLength)+blockNum*vhis.divLength;

	    //These two lines are commented because it's the document body that scrolls in the test and not the div
	    //var blockNum = Math.floor((pos.x+document.getElementById(vhis.pathpanel.domele).scrollLeft-vhis.startX-1)/blockLen);
	    //var tempCounter = Math.floor((pos.x+document.getElementById(vhis.pathpanel.domele).scrollLeft-(blockNum*blockLen+vhis.startX+1))/vhis.sqLength)+blockNum*vhis.divLength;
	    vhis.slidebar.setCounter(Math.min(Math.max(0,tempCounter),vhis.grLength-1));
	});
    this.layer.add(this.group);
    this.vhiSet.canvas.add(this.layer);
}
//accessor and mutator functions
PathSlidebarItem.prototype.getCounter = function() {return this.counter;};
PathSlidebarItem.prototype.setCounter = function(n) {this.counter = n;};
//update slidebar info
PathSlidebarItem.prototype.update = function() {
    this.bot = this.vhiSet.vhiArray[this.vhiSet.vhiArray.length-1].startY+4*this.vhiSet.sqLength;
    this.rect.setHeight(this.bot-this.top);
    this.layer.moveToTop();
    this.layer.draw();
};