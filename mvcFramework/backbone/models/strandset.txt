    def __init__(self, strandType, virtualHelix):
    def __iter__(self):
    def __repr__(self):
    def part(self):
    def document(self):
    def generatorStrand(self):
    def isDrawn5to3(self):
    def isStaple(self):
    def isScaffold(self):
    def getNeighbors(self, strand):
    def complementStrandSet(self):
    def getBoundsOfEmptyRegionContaining(self, baseIdx):
    def indexOfRightmostNonemptyBase(self):
    def partMaxBaseIdx(self):
        """Return the bounds of the StrandSet as defined in the part."""
    def strandCount(self):
    def strandType(self):
    def createStrand(self, baseIdxLow, baseIdxHigh, useUndoStack=True):
    def createDeserializedStrand(self, baseIdxLow, baseIdxHigh, useUndoStack=False):
    def removeStrand(self, strand, strandSetIdx=None, useUndoStack=True, solo=True):
    def removeAllStrands(self, useUndoStack=True):
    def mergeStrands(self, priorityStrand, otherStrand, useUndoStack=True):
    def strandsCanBeMerged(self, strandA, strandB):
    def splitStrand(self, strand, baseIdx, updateSequence=True, useUndoStack=True):
        Break strand into two strands. Reapply sequence by default (disabled
    def strandCanBeSplit(self, strand, baseIdx):
    def destroy(self):
    def remove(self, useUndoStack=True):
    def undoStack(self):
    def virtualHelix(self):
    def strandFilter(self):
    def hasStrandAt(self, idxLow, idxHigh):
    def getOverlappingStrands(self, idxLow, idxHigh):
    def hasStrandAtAndNoXover(self, idx):
    def hasNoStrandAtOrNoXover(self, idx):
    def getIndexToInsert(self, idxLow, idxHigh):
    def getStrand(self, baseIdx):
    def getLegacyArray(self):
    def _addToStrandList(self, strand, idx):
    def _removeFromStrandList(self, strand):
    def _couldStrandInsertAtLastIndex(self, strand):
    def _findOverlappingRanges(self, qstrand, useCache=False):
                # use a next and a default to cause a break condition
    def getStrandIndex(self, strand):
    def _findIndexOfRangeFor(self, strand):
    def _doesLastSetIndexMatch(self, qstrand, strandList):
        def __init__(self, strandSet, baseIdxLow, baseIdxHigh, strandSetIdx):
        def redo(self):
        def undo(self):
        def __init__(self, strandSet, strand, strandSetIdx, solo=True):
        def redo(self):
        def undo(self):
        def __init__(self, strandLow, strandHigh, lowStrandSetIdx, priorityStrand):
        def redo(self):
        def undo(self):
        def __init__(self, strand, baseIdx, strandSetIdx, updateSequence=True):
        def redo(self):
        def undo(self):
    def deepCopy(self, virtualHelix):
